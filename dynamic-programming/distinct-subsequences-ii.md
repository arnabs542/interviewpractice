#### Distinct Subsequences II

> Given a string `S`, count the number of distinct, non-empty subsequences of `S` .
>
> Since the result may be large, **return the answer modulo **`10^9 + 7`.
>
> **Example 1:**
>
> ```
> Input: "abc"
> Output: 7
> Explanation: The 7 distinct subsequences are "a", "b", "c", "ab", "ac", "bc", and "abc".
> ```
>
> **Example 2:**
>
> ```
> Input: "aba"
> Output: 6
>
> Explanation: The 6 distinct subsequences are "a", "b", "ab", "ba", "aa" and "aba".
> ```
>
> **Example 3:**
>
> ```
> Input: "aaa"
> Output: 3
>
> Explanation: The 3 distinct subsequences are "a", "aa" and "aaa".
> ```

##### Brute Force:

The brute force solution simply generates all possible subsequences, adding them to a set, and then seeing how many elements are in the set. This method requires $\small \mathcal O(2^{n})$ time and times out very quickly.

```py
def distinctSubseqII(S):

    s = set()

    def helper(start, S, cur):
        if start >= len(S):
            if len(cur) > 0:
                s.add(cur)
            return
        # include current letter
        helper(start + 1, S, cur + S[start])
        # don't include current letter
        helper(start + 1, S, cur)

    helper(0, S, "")
    return len(s)
```

##### Solution:

Let's simplify the problem a bit. Suppose we had all distinct characters. Then the number of distinct subsequences is simply $\small 2^{n} - 1$, since every subsequence is guaranteed to be unique (subtract the null sequence).

We can establish a recurrence relationship. First, let's not worry about the empty subsequence, since there will only be one, and we can just subtract it at the end. Let `count(i)` be the number of subsequences in `s[:i]`. Then `count(i) = 2*count(i-1)`. For every subsequence in `count(i-1)`, we can append `s[i]` to it, in addition to `s[i]` being its own seqence. 

When we allow duplicate letters, this approach doesn't work, because we end up overcounting. Suppose we have a string `aba`:

```py
count(a) = 1    # "", a
count(ab) = 3    # "", a, ab, b
count(aba) = 6   # "", a, ab, b, aa, ba, aba
```

In the above example, since the subsequence `a` has already been counted by the first `a`, we can't count it in `aba`. 

We can sum up the modified solution as `count(i) = 2*count(i-1) - repetition`. We now simply need to figure out how to find the number of repetitions. 

The key realization is that number of repetitions is simply `count(j)`, where `j` is the previous occurence of the current letter. 

Look at the example input `bcaba`:

```
b: "", b
c: "", b, c, bc
a: "", b, c, bc, a, ba, ca, bca
b: "", b, c, bc, a, ba, ca, bca, (b), bb, cb, bcb, ab, bab, cab, bcab
a: "", b, c, bc, a, ba, ca, bca, (b), bb, cb, bcb, ab, bab, cab, bcab, (a, ba, ca, bca), aa, baa, caa, bcaa, (ba), bba, cba, bcba, aba, baba, caba, bcaba
```

Note for the second `b`, the repetition is the exactly the subsequences generated by **ending with** first `b`. For the second `a`, the repeats `a, ba, ca, bca` are exactly the repeats generated by **ending with** the first `a`. 

In otherwords, for each new letter, we have all the subsequences generated by the previous letters, as well as new subsequences generated by appending the new letter to all the previous subsequences. However, with duplicate letters, the new subsequences that were generated by the last occurence of that letter will be generated again. Those are the repetitions we must remove.

```py
def distinctSubseqII(S):
    dp = [1]
    last_seen = {}

    for i, c in enumerate(S):
        dp.append(dp[-1] * 2)   # Generate subsequences by appending letter
        if c in last_seen:
            dp[-1] -= dp[last_seen[c]]
        last_seen[c] = i
    
    return dp[-1] - 1
```

Strictly speaking, the repetitions would be `dp[last_seen[c]-1]`, but since we initalize our array with `1` for the null string, we implicitly offset by one. 

##### Dynamic Programming:

The idea behind this solution is a bit unintuitive.

The array `endswith[26]` counts how many sub sequence that ends with `i`th character in the alphabet, i.e. `endswith[0]` counts how many sub sequences end with `a`. Suppose we have `N = sum(endswith)` different subsequences. If we add a new character `c` to each of them, then we have `N` different sub sequence that ends with `c`. With this idea, we loop on the whole string `S`,  
 and we update `end[c] = sum(endswith) + 1` for each character. We need to plus one here, because `"c"` itself is also a sub sequence.

**Example:**

Input: `"aba"`  
Current parsed: `"ab"`

`endswith[a]` : `["a"]`  
`endswith[b]` : `["ab","b"]`

`"a"` -&gt;`"aa"`  
`"ab"` -&gt;`"aba"`  
`"b"` -&gt;`"ba"`  
`""` -&gt;`"a"`

`endswith[a]`: `["aa","aba","ba","a"]`  
`endswith[b]`: `["ab","b"]`  
Total: 6

Time complexity is bounded by $\small \mathcal O(26 * n)$, and space bounded by $\small \mathcal O(1)$. We can reduce time complexity to pure $\small \mathcal O(n)$ by utilizing an extra variable to avoid constantly calling `sum(endswith)`.

```py
def distinctSubseqII(S):

    endswith = [0] * 26        
    for char in S:
        endswith[ord(char) - ord('a')] = sum(endswith) + 1

    return sum(endswith) % (10**9 + 7)
```

