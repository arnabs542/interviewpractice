#### Recover a BST

> Two elements of a binary search tree (BST) are swapped by mistake.
>
> Recover the tree without changing its structure.
>
> Example 1:
> 
> Input: [1,3,null,null,2]
>```
>    1
>   /
>  3
>   \
>    2
>
>Output: [3,1,null,null,2]
>
>   3
>  /
> 1
>  \
>   2
>```
> Example 2:
> ```
> Input: [3,1,4,null,null,2]
>
>   3
>  / \
> 1   4
>    /
>   2
>
> Output: [2,1,4,null,null,3]
>
>   2
>  / \
> 1   4
>    /
>   3
> ```

##### Solution

The key to solving this problem is knowing that in-order traversal of a BST returns a sorted array of integers. Since we are told that there are only two nodes that are out of position, then there will be two elements that will be out of order. 

The simplest approach would be to simply traverse the tree, store the elements, then look for out of order elements:

```py
def recoverTree(root: "TreeNode") -> None:
    """
    Do not return anything, modify root in-place instead.
    """
    vals = []
    def in_order(root, vals):
        if not root:
            return
        in_order(root.left, vals)
        vals.append(root)
        in_order(root.right, vals)
    
    in_order(root, vals)
    
    # Swap two elements to make array sorted
    first_conflict = -1
    for i in range(len(vals) - 1):
        if vals[i].val > vals[i+1].val:
            first_conflict = i
            break
    
    second_conflict = -1
    for i in range(len(vals) - 1, 0, -1):
        if vals[i].val < vals[i-1].val:
            second_conflict = i
            break
        
    vals[first_conflict].val, vals[second_conflict].val = vals[second_conflict].val, vals[first_conflict].val
    
    return
```

This requires $\small \mathcal O(n)$ time and space. 

We can get rid of the extra array by keeping two variables as we do our traversal, but this still relies on the space generated by the recursion stack. In order for a true $\small \mathcal O(1)$ space solution, we need to use a Morris Traversal:

```py
def recoverTree(root: "TreeNode") -> None:
    """
    Do not return anything, modify root in-place instead.
    """
    
    cur = root
    prev = TreeNode(float('-inf'))
    first = second = None
    
    while cur:
        if not cur.left:
            if first is None and cur.val <= prev.val:
                first = prev
            if first is not None and cur.val <= prev.val:
                second = cur
            prev = cur
            cur = cur.right
        else:
            # Find predecessor
            pred = cur.left
            while (pred.right and pred.right != cur):
                pred = pred.right
            if pred.right is None:
                pred.right = cur
                cur = cur.left
            else:
                pred.right = None
                if first is None and cur.val <= prev.val:
                    first = prev
                if first is not None and cur.val <= prev.val:
                    second = cur
                prev = cur
                cur = cur.right
    
    first.val, second.val = second.val, first.val
```

The general idea of a Morris traversal can be summed in the Python psuedocode below:

```py
def morris(root):
    current = root
    while current is not None:
        if current.left is None:
            visit(current)
        else:
            predecessor = find_predecessor(root)
            if predecessor.right is None:
                predecessor.right = current
                current = current.left
            else:
                predecessor.right = None
                visit(current)
                current = current.right
```

A Morris traversal is still $\small \mathcal O(n)$ time - each node is visited no more than 3 times, once in the predecessor path, once in visiting the node itself, and once to remove the successor pointer.